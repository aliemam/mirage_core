<?php

/**
 *
 *
 * NOT COMPLETED YET. DO NOT CHANGE SOURCE CODE
 *
 *
 */
/**
 * This is part of Mirage Micro Framework
 *
 * @author Ali Emamhadi <aliemamhadi@gmail.com>
 */

namespace Mirage\Libs;

use Mirage\Constants\Err;
use Mirage\Exceptions\HttpException;
use Phalcon\Security;

/**
 * Class RequestHash
 *
 * This class is for better handling requests, made by clients or even servers and controllers them security vise.
 * It can prevent duplicated requests or even request from one ip more than n time in specific m seconds.
 * The important concept of this class is a hash string that helps us unified each request.
 * There is 4 parameters that generates this request hashes.
 * first we have app version that already calls apis.
 * second we have exact time that actually request generated by client.
 * third we have 4 digit random number that clients generate at the time of making any request.
 * the last parameter needed by this class is a key.
 * this key could be generated for each version of app and stored in db.
 * in that case you can easily deprecate some clients uses that version by that key.
 *
 * @package Mirage\Libs
 */
final class RequestHash
{

    /** @var string this is hash created on client side which is proof that client is real */
    private static string $client_hash_token;

    /** @var string version of app */
    private static string $version;

    /** @var string unix timestamp that request was made */
    private static string $time;

    /** @var string random 4 digit number generate at the time request will be made */
    private static string $random;

    /** @var string key for sha256 algorithm */
    private static string $key;

    /**
     * Do not let outer world create this class
     */
    private function __construct()
    {
    }

    /**
     * In case of error occurred, this function handle that error based on $bypass_error variable.
     * Variable $throw_exception_on_error controls action of throwing error and terminate process
     * if anything goes wrong.
     * So do not set it to true unless you know what you are doing. This is matter of app security.
     * @param HttpException $http
     * @param bool $throw_exception_on_error
     * @return void
     * @throws HttpException
     * @throws \ErrorException
     */
    private static function error(HttpException $http, bool $throw_exception_on_error): void
    {
        if (!$throw_exception_on_error) {
            L::d($http->getMessage());
            return;
        } else {
            (new Security())->hash(rand());
            throw $http;
        }
    }

    /**
     * Checking for valid request from client.
     * @param bool $throw_exception_on_error if this variable was set to false,
     * on any authentication failure, this class does not throw an error so be careful with it.
     * @return bool
     * @throws HttpException
     * @throws \ErrorException
     */
    private static function validateRequestHash(bool $throw_exception_on_error = true): bool
    {
        if (!$throw_exception_on_error) {
            L::w('!!!CHECK AUTH TOKEN WARNING ---> BYPASSED ON ERROR!!!');
        }

        if (!isset($client_hash_token)) {
            self::error(new HttpException(
                Err::REQUEST_HASH_CLIENT_TOKEN_INVALID,
                'client hash token in invalid.'
            ), $throw_exception_on_error);
            return false;
        }

        $hash_token = self::generateRequestHash();
        if (!isset($hash_token)) {
            self::error(
                new HttpException(Err::REQUEST_HASH_TOKEN_INVALID, 'hash token in invalid.'),
                $throw_exception_on_error
            );
            return false;
        }

        if ($hash_token !== self::$client_hash_token) {
            L::d("created hash: $hash_token");
            L::d("client hash: " . self::$client_hash_token);
            self::error(
                new HttpException(Err::REQUEST_HASH_TOKENS_NOT_IDENTICAL, 'hashes are not identical'),
                $throw_exception_on_error
            );
            return false;
        }
        L::d('hashes are identical');

        return true;
    }

    /**
     * @return string
     * @throws HttpException
     * @throws \ErrorException
     */
    public static function generateRequestHash(): string
    {
        $hash_key = Config::get('app.security.request_hash_key');
        if (!isset($hash_key)) {
            self::error(new HttpException(
                Err::REQUEST_HASH_KEY_NOT_FOUND,
                'hash key is not set yet. please set hash key first.'
            ), true);
            return null;
        }
        if (!isset(self::$version)) {
            self::error(new HttpException(
                Err::REQUEST_HASH_KEY_NOT_FOUND,
                'hash key is not set yet. please set hash key first.'
            ), true);
            return null;
        }
        if (!isset(self::$time)) {
            self::$time = time();
        }
        if (!isset(self::$random)) {
            self::$random = rand(1000, 9999);
        }

        L::d("generate request hash with version: " . self::$version . " time:" . self::$time .
            " random:" . self::$random);
        return hash('sha256', $hash_key . self::$version . self::$time . self::$random);
    }


    /**
     * Checking for valid request from client.
     * @param bool $throw_exception_on_error if this variable was set to false,
     * on any authentication failure, this class does not throw an error so be careful with it.
     * @return bool
     * @throws HttpException
     * @throws \ErrorException
     */
    public static function checkForInvalidRequest(bool $throw_exception_on_error = true): bool
    {
        return self::validateRequestHash($throw_exception_on_error);
    }

    /**
     * Checking if request was duplicated.
     * @param int $expiration_time it means after how many seconds client can make the same request hash..
     * @param bool $throw_exception_on_error
     * @return bool
     * @throws HttpException
     * @throws \ErrorException
     */
    public static function checkForDuplicatedRequest(int $expiration_time, bool $throw_exception_on_error = true): bool
    {
        $cache_id = "request_hash:" . self::$client_hash_token;
        $request_hash = Cache::get($cache_id);
        if ($request_hash !== null) {
            self::error(
                new HttpException(Err::REQUEST_HASH_DUPLICATED, 'request duplicated.'),
                $throw_exception_on_error
            );
            return false;
        }

        Cache::add($cache_id, 0, $expiration_time);
        return true;
    }

    /**
     * Checking some ip makes too many requests in short time .
     * @param int $request_limit_number number of request allowed to call in $duration
     * @param int $duration in seconds
     * @param bool $throw_exception_on_error
     * @return bool
     * @throws \Exception
     */
    public static function checkLimitRequestPerIP(
        int $request_limit_number,
        int $duration,
        bool $throw_exception_on_error = true
    ): bool {
        $cache_id = "request_hash:" . Helper::getIP();
        $request_data = Cache::get($cache_id);
        $count = $request_data ?? 0;
        Cache::add($cache_id, ++$count, $duration);

        return ($request_data === null || $request_data <= $request_limit_number);
    }

    /**
     * @param string $version
     */
    public static function setVersion(string $version): void
    {
        self::$version = $version;
    }

    /**
     * @param string $time
     */
    public static function setTime(string $time): void
    {
        self::$time = $time;
    }

    /**
     * @param string $random
     */
    public static function setRandom(string $random): void
    {
        self::$random = $random;
    }

    /**
     * @param string $key
     */
    public static function setKey(string $key): void
    {
        self::$key = $key;
    }

    /**
     * @param string $client_hash_token
     */
    public static function setClientHashToken(string $client_hash_token): void
    {
        self::$client_hash_token = $client_hash_token;
    }
}
