<?php

/**
 *
 *
 * NOT COMPLETED YET. DO NOT CHANGE SOURCE CODE
 *
 *
 */

/**
 * This is part of Mirage Micro Framework
 *
 * @author Ali Emamhadi <aliemamhadi@gmail.com>
 */

namespace Mirage\Libs;

use ErrorException;
use App\Constants\Err;
use Mirage\Exceptions\HttpException;
use Phalcon\Cache\Exception\InvalidArgumentException;

/**
 * Class RequestHash
 *
 * This class is for better handling requests, made by clients or even servers and controllers them security vise.
 * It can prevent duplicated requests or even request from one ip more than n time in specific m seconds.
 * The important concept of this class is a hash string that helps us unified each request.
 * There is 4 parameters that generates this request hashes.
 * first we have app version that already calls apis.
 * second we have exact time that actually request generated by client.
 * third we have 4 digit random number that clients generate at the time of making any request.
 * the last parameter needed by this class is a key.
 * this key could be generated for each version of app and stored in db.
 * in that case you can easily deprecate some clients uses that version by that key.
 *
 * @package Mirage\Libs
 */
final class RequestHash
{

    /** @var string this is hash created on client side which is proof that client is real */
    private ?string $client_hash_token;

    /** @var string private key to create hash */
    private ?string $private_key;

    /** @var string version of app */
    private ?string $version;

    /** @var string unix timestamp that request was made */
    private ?string $time;

    /** @var string random 4 digit number generate at the time request will be made */
    private ?string $random;

    /** @var string key for sha256 algorithm */
    private ?string $key;

    /** @var Cache is cache to store request hash */
    private Cache $cache;

    /**
     * Do not let outer world create this class
     * @param string $private_key
     * @param Cache $cache
     * @throws HttpException
     */
    public function __construct(string $private_key, Cache $cache)
    {
        $this->private_key = $private_key;
        $this->cache = $cache;
        $headers = Helper::getHeaders();
        if (!isset($headers['M-HASH'])) {
            throw new HttpException(Err::REQUEST_HASH_KEY_NOT_FOUND, 'M-HASH is not set.');
        }
        if (!isset($headers['M-VERSION'])) {
            throw new HttpException(Err::REQUEST_HASH_VERSION_NOT_FOUND, 'M-VERSION is not set.');
        }
        if (!isset($headers['M-TIME'])) {
            throw new HttpException(Err::REQUEST_HASH_TIME_NOT_FOUND, 'M-TIME is not set.');
        }
        if (!isset($headers['M-RANDOM'])) {
            throw new HttpException(Err::REQUEST_HASH_RANDOM_NOT_FOUND, 'M-RANDOM is not set.');
        }

        $this->client_hash_token = $headers['M-HASH'];
        $this->version = $headers['M-VERSION'];
        $this->time = $headers['M-TIME'];
        $this->random = $headers['M-RANDOM'];
    }

    /**
     * Checking for valid request from client.
     * @return void
     * @throws ErrorException
     */
    private function checkForInvalidRequest(): void
    {
        $hash_token = hash('sha256', $this->private_key . $this->version . $this->time . $this->random);
        if ($hash_token !== $this->client_hash_token) {
            L::d("created hash: $hash_token");
            L::d("client hash: " . $this->client_hash_token);
            throw new HttpException(Err::REQUEST_HASH_TOKENS_NOT_IDENTICAL, 'hashes are not identical');
        }
        L::d('checkForInvalidRequest passed');
    }

    /**
     * Checking if request was duplicated.
     * @param int $rest_sec it means after how many seconds client can make the same request hash..
     * @return void
     * @throws ErrorException
     * @throws HttpException
     * @throws InvalidArgumentException
     */
    public function checkForDuplicatedRequest(int $rest_sec): void
    {
        $cache_id = "request_hash:" . Helper::getIP() . $this->client_hash_token;
        $request_hash = $this->cache->get($cache_id);
        if ($request_hash !== null) {
            throw new HttpException(Err::REQUEST_HASH_DUPLICATED, 'request duplicated.');
        }
        $this->cache->add($cache_id, 0, $rest_sec);
        L::d('checkForDuplicatedRequest passed');
    }

    /**
     * Checking some ip makes too many requests in short time .
     * @param int $request_limit_number number of request allowed to call in $duration
     * @param int $duration in seconds
     * @return void
     * @throws ErrorException|InvalidArgumentException
     */
    public function checkLimitRequestPerIP(int $request_limit_number, int $duration): void
    {
        $cache_id = "request_hash:" . Helper::getIP() . $this->client_hash_token;
        $request_count = $this->cache->get($cache_id);
        if ($request_count === null) {
            $this->cache->add($cache_id, 1, $duration);
            L::d('checkLimitRequestPerIP first request');
            return;
        }
        if ($request_count > $request_limit_number) {
            throw new HttpException(Err::REQUEST_HASH_IP_CALL_LIMIT, 'request reach its limit.');
        }
        $this->cache->increment($cache_id);
    }
}
